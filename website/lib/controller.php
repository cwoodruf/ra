<?php
# base controller class
class Controller {
	# these describe what you are trying to do
	public $actions; # array with $_REQUEST['action'] split at the /s
	public $controller; # string 
	# these are for autogenerated forms
	public $input;
	public $hidden;
	# map of action => method names
	public $doable; 

	public function __construct($actions=null) {
		View::assign('this',$this);
		$this->controller = strtolower(get_class($this));
		$this->action = self::r(ACTION);
		$this->actions = $actions;
	}
	
	public function getaction($i) {
		return self::v($this->actions,$i);
	}

	# shut up error reporting for empty request vars etc
	public static function r($key) {
		return self::v($_REQUEST,$key);
	}
	public static function v($ary,$key) {
		if (!is_array($ary)) return null;
		return isset($ary[$key]) ? $ary[$key] : null;
	}

	# figure out which controller you want to run
	public static function init() {
		$actions = array();

		if (is_array(self::r(ACTION))) {
			$actions = self::r(ACTION);
		} else if (isset($_REQUEST['action'])) {
			$actions = explode('/', $_REQUEST[ACTION]);
		} else if (isset($_SERVER['PATH_INFO'])) {
			$actionstr = preg_replace('#^/#','',$_SERVER['PATH_INFO']);
			$actions = explode('/', $actionstr);
		}
		$controller = self::v($actions,0);

		if (!Check::isvar($controller,false)) $controller = DEFCONTROLLER;

		# avoid situations where we repeatedly go back to log in form when we are already logged in
		if (isset($_SESSION[LOGINSESSION]['login']) and !strcasecmp($controller,LOGINCONTROLLER)) {
			$controller = DEFCONTROLLER;
		}

		return array($controller,$actions);
	}

	# map class methods to actions
	public function doable($actionlist) {
		if (!is_array($actionlist)) return;
		foreach ($actionlist as $action => $method) {
			if (Check::isvar($action) and Check::isvar($method)) {
				$this->doable[$action] = $method;
			}
		}
	}

	# do a method based on an action
	public function doaction($action=null) {
		if (!isset($action)) $action = $this->actions[1];
		if (!$action or !$this->doable[$action]) $action = 'default';
		$callback = self::v($this->doable,$action);
		if (!$callback) return;
		if (!method_exists($this,$callback)) {
			if (!QUIET) die("callback $callback for action $action doesn't exist");
			return;
		}
		return $this->$callback();
	}

	# restore saved request
	public static function redo() {
		$_REQUEST = $_SESSION[LOGINSESSION]['request'];
		include('index.php');
		exit;
	}

	# find a controller - should probably make a path making function
	public function path($controller) {
		return CONTROLLERSDIR."/".strtolower($controller).".php";
	}

	# flags are a way to provide stateful interprocess communications
	# any controller can check the state of any flag set by any other 
	# controller
	public function flag($flag,$value=null) {
		@session_start();
		if (isset($value)) $_SESSION[LOGINSESSION]['flags'][$flag] = $value;
		return $_SESSION[LOGINSESSION]['flags'][$flag];
	}

	public function delflag($flag) {
		@session_start();
		$value = $_SESSION[LOGINSESSION]['flags'][$flag];
		unset($_SESSION[LOGINSESSION]['flags'][$flag]);
		return $value;
	}

	public function delflags() {
		@session_start();
		$flags = $_SESSION[LOGINSESSION]['flags'];
		unset($_SESSION[LOGINSESSION]['flags']);
		return $flags;
	}

	# these are used by the tools/formgen.tpl template right now
	public function input($field=null) {
		if (!is_array($this->input)) return;
		if (isset($this->input[$field])) return htmlentities($this->input[$field]);
		return;
	}

	# these are used by the tools/formgen.tpl template right now
	public function hidden($field=null) {
		if (!is_array($this->hidden)) return;
		if (isset($this->hidden[$field])) return htmlentities($this->hidden[$field]);
		return;
	}

	public function css() {
		return View::$css.View::$css_at_end;
	}

	public function js() {
		return View::$js.View::$js_at_end;
	}
	
	public function sitedir() {
		return dirname($_SERVER['SCRIPT_NAME']);
	}

	public function title($title=null) {
		if (!empty($title)) $this->title = $title;
		if (!isset($this->title)) return get_class($this);
		return $this->title;
	}
}

